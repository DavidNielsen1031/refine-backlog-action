name: "Refine Backlog"
description: "Transform messy backlog items into structured, actionable work items using AI"
branding:
  icon: "check-square"
  color: "blue"

inputs:
  items:
    description: "Backlog items to refine (newline-separated). Use either this OR file."
    required: false
  file:
    description: "Path to a file containing backlog items (one per line)"
    required: false
  key:
    description: "Refine Backlog license key. Can also be set via REFINE_BACKLOG_KEY env var."
    required: false
  user-stories:
    description: "Add a user story title to each refined item"
    required: false
    default: "false"
  gherkin:
    description: "Write acceptance criteria in Given/When/Then format"
    required: false
    default: "false"
  context:
    description: "Project context to guide the AI (e.g. 'B2B SaaS, TypeScript, Agile team of 5')"
    required: false
  output-file:
    description: "Write refined JSON output to this file path (e.g. refined.json)"
    required: false
  write-back:
    description: "Write refined output back to the GitHub issue as a comment (requires issues: write permission)"
    required: false
    default: "false"

outputs:
  refined:
    description: "JSON string of all refined backlog items"
    value: ${{ steps.refine.outputs.refined }}
  count:
    description: "Number of items successfully refined"
    value: ${{ steps.refine.outputs.count }}
  refined_file:
    description: "Path to a temp file containing the refined JSON (safe for downstream shell use)"
    value: ${{ steps.refine.outputs.refined_file }}

runs:
  using: "composite"
  steps:
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: "20"

    - name: Checkout (only when reading from a file)
      if: ${{ inputs.file != '' }}
      uses: actions/checkout@v4

    - name: Refine backlog items
      id: refine
      shell: bash
      env:
        REFINE_BACKLOG_KEY: ${{ inputs.key || env.REFINE_BACKLOG_KEY }}
        RB_CONTEXT: ${{ inputs.context }}
      run: |
        set -e

        # Auto-detect context if not provided explicitly
        if [ -z "$RB_CONTEXT" ]; then
          AUTO_CONTEXT=""
          for f in AGENTS.md CLAUDE.md CURSOR.md .cursorrules README.md; do
            if [ -f "$f" ]; then
              AUTO_CONTEXT=$(head -c 600 "$f")
              break
            fi
          done
          # package.json fallback
          if [ -z "$AUTO_CONTEXT" ] && [ -f "package.json" ]; then
            AUTO_CONTEXT=$(node -e "
              const p = require('./package.json');
              const deps = Object.keys(p.dependencies || {}).slice(0, 10).join(', ');
              console.log([p.name, p.description, deps ? 'deps: ' + deps : ''].filter(Boolean).join('. '));
            " 2>/dev/null || echo "")
          fi
          if [ -n "$AUTO_CONTEXT" ]; then
            # Sanitize: strip backticks and backslashes that break shell eval
            AUTO_CONTEXT=$(printf '%s' "$AUTO_CONTEXT" | tr -d '`\\')
            RB_CONTEXT="$AUTO_CONTEXT"
            echo "Auto-detected context from repo files (${#RB_CONTEXT} chars)"
          fi
        fi

        # Build CLI argument list
        ARGS="--format json"

        if [ "${{ inputs.user-stories }}" = "true" ]; then
          ARGS="$ARGS --user-stories"
        fi
        if [ "${{ inputs.gherkin }}" = "true" ]; then
          ARGS="$ARGS --gherkin"
        fi
        # Pass context via env var to avoid shell word-splitting on spaces
        if [ -n "$RB_CONTEXT" ]; then
          ARGS="$ARGS --context \"$RB_CONTEXT\""
        fi

        # Handle inline items â€” write to temp file to avoid shell quoting issues
        if [ -n "${{ inputs.items }}" ]; then
          ITEMS_FILE=$(mktemp)
          printf '%s' "${{ inputs.items }}" > "$ITEMS_FILE"
          ARGS="$ARGS --file $ITEMS_FILE"
        elif [ -n "${{ inputs.file }}" ]; then
          ARGS="$ARGS --file ${{ inputs.file }}"
        else
          echo "::error::Either 'items' or 'file' input is required."
          exit 1
        fi

        # Run the CLI
        echo "::group::Refine Backlog output"
        REFINED=$(eval npx --yes refine-backlog-cli $ARGS)
        echo "::endgroup::"

        # Parse item count
        COUNT=$(echo "$REFINED" | node -e "
          let data = '';
          process.stdin.on('data', c => data += c);
          process.stdin.on('end', () => {
            try { const p = JSON.parse(data); console.log(Array.isArray(p) ? p.length : (p.items || []).length); }
            catch(e) { console.log(0); }
          });
        " 2>/dev/null || echo "0")

        echo "âœ… Refined $COUNT item(s)"

        # Write JSON to a stable temp file (safe for downstream steps â€” no quoting issues)
        REFINED_FILE=$(mktemp /tmp/refine-backlog-XXXXXX.json)
        echo "$REFINED" > "$REFINED_FILE"

        # Set outputs
        {
          echo "refined<<EOF"
          echo "$REFINED"
          echo "EOF"
          echo "count=$COUNT"
          echo "refined_file=$REFINED_FILE"
        } >> "$GITHUB_OUTPUT"

        # Write to user-specified output file if requested
        if [ -n "${{ inputs.output-file }}" ]; then
          cp "$REFINED_FILE" "${{ inputs.output-file }}"
          echo "ðŸ“„ Written to ${{ inputs.output-file }}"
        fi

    - name: Write back to issue
      if: ${{ inputs.write-back == 'true' && github.event_name == 'issues' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        ISSUE_NUMBER="${{ github.event.issue.number }}"
        REPO="${{ github.repository }}"

        # Read from the temp file written by the refine step â€” safe, no quoting issues
        REFINED_FILE="${{ steps.refine.outputs.refined_file }}"

        # Format the comment with Node reading from the temp file
        COMMENT=$(node -e "
          const fs = require('fs');
          const raw = JSON.parse(fs.readFileSync('$REFINED_FILE', 'utf8')); const items = Array.isArray(raw) ? raw : (raw.items || []);
          const lines = ['## ðŸ¤– Refine Backlog Results', ''];
          items.forEach((item, i) => {
            lines.push(\`### \${i + 1}. \${item.title}\`);
            lines.push('');
            lines.push(\`**Priority:** \${item.priority}\`);
            lines.push(\`**Estimate:** \${item.estimate}\`);
            lines.push('');
            lines.push(\`**Problem:** \${item.problem}\`);
            lines.push('');
            lines.push('**Acceptance Criteria:**');
            item.acceptanceCriteria.forEach(ac => lines.push(\`- \${ac}\`));
            if (item.userStory) {
              lines.push('');
              lines.push(\`**User Story:** \${item.userStory}\`);
            }
            if (item.tags?.length) {
              lines.push('');
              lines.push(\`**Tags:** \${item.tags.join(', ')}\`);
            }
            if (item.assumptions?.length) {
              lines.push('');
              lines.push('**Open Questions:**');
              item.assumptions.forEach(a => lines.push(\`- \${a}\`));
            }
            lines.push('');
            lines.push('---');
            lines.push('');
          });
          lines.push('_Powered by [Refine Backlog](https://refinebacklog.com)_');
          process.stdout.write(lines.join('\n'));
        ")

        gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$COMMENT"
        echo "âœ… Comment posted to issue #$ISSUE_NUMBER"
